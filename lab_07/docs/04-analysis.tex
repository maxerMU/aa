\chapter{Аналитический раздел}

В данном разделе представленные теоретические сведения о рассматриваемых алгоритмах.

\section{Линейный поиск}

Алгоритм линейного поиска заключается в проходе по словарю, до того момента, пока не будет найден искомый ключ. В рассматриваемом алгоритме возможно $N + 1$ случаев расположения ключа: ключ является $i$-ым элементом словаря либо его нет в словаре в принципе. 

Лучший случай (трудоемкость $O(1)$): ключ расположен в самом начале словаря и найден за одно сравнение). Худший случай (трудоемкость $O(N)$): ключ расположен в самом конце словаря либо ключ не находится в словаре. Средний случай: $O(N/2) = O(N)$.

\section{Двоичный поиск}

Данный алгоритм подходит только для заранее упорядоченного словаря.

Процесс двоичного поиска можно описать следующим образом: 

\begin{itemize}
	\item получить значение находящееся в середине словаря и сравнить его с ключом;
	\item в случае, если ключ меньше данного значения, продолжить поиск в младшей части словаря, в обратном случае -- в старшей части словаря;
	\item на новом интервале снова получить значение из середины этого интервала и сравнить с ключом.
	\item поиск продолжать до тех пор, пока не будет найден искомый ключ, или интервал поиска не окажется пустым.
\end{itemize}

Обход словаря данным алгоритм можно представить в виде дерева, поэтому трудоемкость в худшем случае и в среднем составит $\log_{2}{N}$. Трудоёмкость в лучшем случае: $O(1)$ (элемент сразу оказался средним). Можно сделать вывод, что алгоритм двоичного поиска работает значительно быстрее, чем алгоритм линейного поиска, однако при этом он требует предварительной обработки данных (сортировки).

\section{Поиск по сегментам}

Данный алгоритм также требует предварительной обработки данных, а именно:
\begin{itemize}
	\item упорядочить словарь;
	\item разбить словарь на сегменты.
\end{itemize}

Словарь разбивается на сегменты по какому-либо признаку и сортируется по частоте. Например, если ключ является строкой, то можно сделать разбиение по первой букве в ключе. Если ключ является целым числом, можно провести разбиение по остатку от деления ключа на некоторое число $K$.

После выполнения разбиения, нужно определить к какому сегменту относится искомый ключ и провести на этом сегменте двоичный поиск.

Таким образом, так же, как и алгоритм двоичного поиска, поиск по сегментам требует предварительной обработки данных. 

Трудоёмкость поиска по сегментам складывается из двух величин: трудоёмкости линейного поиска сегмента и бинарного поиска внутри сегмента.

\section{Описание словаря}
Словарь представляет собой массив пар (название страны, число заболевших коронавирусом). Информация взята с API, предоставляемого сайтом covid-19 tracking \cite{covid}.

\section*{Вывод}
В данном разделе были рассмотрены особенности алгоритмов поиска в словаре. Кроме того, были приведены трудоёмкости каждого из алгоритмов.
Входными данными для программного обеспечения являются словарь, ключ для поиска в словаре и функция, задающая операцию отношения на множестве элементов словаря.