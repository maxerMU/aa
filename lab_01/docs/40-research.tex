\chapter{Исследовательская часть}

\section{Пример работы}

Демонстрация работы программы приведена на рисунке \ref{img:work}.

\boximg{100mm}{work}{Демонстрация работы алгоритмов нахождения расстояния Левенштейна и Дамерау -- Левенштейна}

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось тестирование:

\begin{itemize}
	\item Операционная система: Windows 10 Pro \cite{windows} 64-bit.
	\item Память: 8 GB.
	\item Процессор: Intel(R) Core(TM) i5-4460 \cite{Intel} CPU @ 3.20GHz
\end{itemize}

Тестирование проводилось на компьютере, включенном в сеть электропитания. Во время тестирования компьютер был нагружен только встроенными приложениями окружения рабочего стола, окружением рабочего стола, а также непосредственно системой тестирования.

\section{Время выполнения алгоритмов}

Алгоритмы тестировались при помощи функции GetProcessTimes \cite{GetProcessTimes}, предоставяющей возможность измерить процессорное время на программе на языке C++, запущенной на операционной системе Windows. Для получения более точных результатов тестирования, функции выполнялись большое количество раз. Количество повторов было подобрано таким образом, чтобы все значения времени выполнения функций были различны, но не занимали избыточно много времени. Рекурсивная реализация алгоритма вычисления расстояния Левенштейна не тестировалась при длине слов больше 9, из-за слишком большого времени работы.

Результаты замеров (в мс) приведены на рисунке \ref{img:time}.
На рисунках \ref{plt:time_levenshtein} и \ref{plt:time_dl} приведены зависимости времени работы алгоритмов от длины строк.

\boximg{80mm}{time}{Замер времени для строк, размером от 5 до 50}

\begin{figure}[h]
	\centering
	\begin{tikzpicture}
		\begin{axis}[
			axis lines=left,
			xlabel=Длина строк,
			ylabel={Время, нс},
			legend pos=north west,
			ymajorgrids=true
		]
			\addplot table[x=len,y=RecursiveMatrix,col sep=comma] {inc/csv/time_recmat.csv};
			\addplot table[x=len,y=IterativeMatrix,col sep=comma] {inc/csv/time_itmat.csv};
			\legend{Рекурсивный с матрицей, Матричный}
		\end{axis}
	\end{tikzpicture}
	\captionsetup{justification=centering}
	\caption{Зависимость времени работы (в мс) алгоритма вычисления расстояния Левенштейна от длины строк (рекурсивная с заполнением матрицы и матричная реализации)}
	\label{plt:time_levenshtein}
\end{figure}

\begin{figure}
	\centering
	\begin{tikzpicture}
		\begin{axis}[
			axis lines=left,
			xlabel=Длина строк,
			ylabel={Время, мс},
			legend pos=north west,
			ymajorgrids=true
		]
			\addplot table[x=len,y=IterativeMatrix,col sep=comma] {inc/csv/time_itmat.csv};
			\addplot table[x=len,y=DamerauLevenshtein,col sep=comma] {inc/csv/time_dl.csv};
			\legend{Левенштейн, Д. — Левенштейн}
		\end{axis}
	\end{tikzpicture}
	\captionsetup{justification=centering}
	\caption{Зависимость времени работы (в мс) матричных реализаций алгоритмов вычисления расстояний Левенштейна и Дамерау — Левенштейна}
	\label{plt:time_dl}
\end{figure}

\section{Использование памяти}

Алгоритмы вычисления расстояний Левенштейна и Дамерау — Левенштейна не отличаются друг от друга с точки зрения использования памяти, следовательно, достаточно рассмотреть лишь разницу рекурсивной и матричной реализаций этих алгоритмов.

Максимальная глубина стека вызовов при рекурсивной реализации равна сумме длин входящих строк, соответственно, максимальный расход памяти вычисляется по формуле (\ref{for:99})
\begin{equation}
(\mathcal{C}(S_1) + \mathcal{C}(S_2)) \cdot (2 \cdot \mathcal{C}\mathrm{(string)} + 2 \cdot \mathcal{C}\mathrm{(size\_t)} + \mathcal{C}\mathrm{(bool)}),
\label{for:99}
\end{equation}
где $\mathcal{C}$ — оператор вычисления размера, $S_1$, $S_2$ — строки, $\mathrm{size\_t}$ \cite{sizet} — целочисленный тип, $\mathrm{string}$ — строковый тип,  $\mathcal{C}\mathrm{(bool)}$ - логический тип.

Использование памяти при итеративной реализации теоретически вычисляется по формуле (\ref{for:100}).
\begin{equation}
(\mathcal{C}(S_1) + 1) \cdot (\mathcal{C}(S_2) + 1) \cdot \mathcal{C}\mathrm{(size\_t)} + 5\cdot \mathcal{C}\mathrm{(size\_t)} + 2 \cdot \mathcal{C}\mathrm{(string)})
\label{for:100}
\end{equation}

Использование памяти при рекурсивной реализации с заполнением матрицы теоретически равно сумме использумой памяти в рекурсивном и итеративном алгоритмах.

\section*{Вывод}

Рекурсивный алгоритм вычисления расстояния Левенштейна работает на порядок дольше итеративных реализаций, время его работы увеличивается в геометрической прогрессии. На словах длиной 9 символов, матричная реализация алгоритма вычисления расстояния Левенштейна превосходит по времени работы рекурсивную в около 7000 раз. Рекурсивный алгоритм с заполнением матрицы превосходит простой рекурсивный на аналогичных данных в около 4500 раз. Алгоритм вычисления расстояния Дамерау — Левенштейна используется для решения других задач, поэтому говорить о его отставании от алгоритма вычисления расстояния Левенштейна, исходя из временных затрат, некорректно.

По расходу памяти алгоритмы с использованием матрицы проигрывают рекурсивному: максимальный размер используемой памяти в них растёт как произведение длин строк, в то время как у рекурсивного алгоритма — как сумма длин строк.
